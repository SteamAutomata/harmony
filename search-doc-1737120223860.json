{"searchDocs":[{"title":"Installation","type":0,"sectionRef":"#","url":"/harmony/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Using Wally​","type":1,"pageTitle":"Installation","url":"/harmony/docs/intro#using-wally","content":" -# wip  ","version":"Next","tagName":"h2"},{"title":"Using NPM​","type":1,"pageTitle":"Installation","url":"/harmony/docs/intro#using-npm","content":" -# wip  ","version":"Next","tagName":"h2"},{"title":"Using Nothing​","type":1,"pageTitle":"Installation","url":"/harmony/docs/intro#using-nothing","content":" -# wip ","version":"Next","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/harmony/docs/Examples","content":"","keywords":"","version":"Next"},{"title":"Kill brick​","type":1,"pageTitle":"Examples","url":"/harmony/docs/Examples#kill-brick","content":" The simplest example of creating a killbrick, cleaning itself up if the tag is removed.  -# wip  ","version":"Next","tagName":"h2"},{"title":"Money Service​","type":1,"pageTitle":"Examples","url":"/harmony/docs/Examples#money-service","content":" This is an example for a service handling player currencies. Obviously, clients can't access Providers on the server, so we would need to use the player state!  -# wip  ","version":"Next","tagName":"h2"},{"title":"Make a custom health system​","type":1,"pageTitle":"Examples","url":"/harmony/docs/Examples#make-a-custom-health-system","content":" When making a combat game, you would want to apply armors, apply effects like poison or withering.  Using components, you can add extra behaviors to Humanoid, and instead of using Humanoid:TakeDamage(number), you will use HealthManager:TakeDamage(number, options) and even HealthManager:Poison(damage, duration) which will account armor points and modifiers!  For modifiers, we will use Boost! You can get it on the marketplace here!  -# wip ","version":"Next","tagName":"h2"},{"title":"The Beginnings of Harmony Framework","type":0,"sectionRef":"#","url":"/harmony/blog/2025/01/11/how-it-started","content":"","keywords":"","version":null},{"title":"Introduction​","type":1,"pageTitle":"The Beginnings of Harmony Framework","url":"/harmony/blog/2025/01/11/how-it-started#introduction","content":" ","version":null,"tagName":"h2"},{"title":"Where did it started and what did evolved ?​","type":1,"pageTitle":"The Beginnings of Harmony Framework","url":"/harmony/blog/2025/01/11/how-it-started#where-did-it-started-and-what-did-evolved-","content":" Harmony Framework is a new Roblox framework I've been using internally for years. In its early stages, it was simply a set of libraries called Melody. However, as my projects grew, I realized my code had significant flaws, even with the libraries making things easier.  Global RemoteEvents weren’t typed and were poorly optimized. Global state management was also untyped, relying on ValueBase objects. RemoteEvents were untyped, inter-script communication used BindableEvents with major issues, and managing replicated player data was done with Attributes, which are very bandwidth-expensive. And on top of the cake, my code was not consistent at all.  Giving myself too much freedom on how to write code was the top of the cake. Inconsistencies everywheres, scripts parented in unusual places, questionnable naming conventions. I needed some sort of constraint to keep myself from rewriting the entire code every week.  At that point, I moved away from Melody Framework and started using RobloxTS, but it had its own set of issues. I needed quick development, and RobloxTS or Rojo tools didn’t fit the project’s conditions, so using Flamework wasn’t ideal. Knit was unmaintained (I think?), and it wasn't type-safe. Prvd m' Wrong is still in early development and didn’t meet my needs.  ","version":null,"tagName":"h2"},{"title":"The goals of this new framework​","type":1,"pageTitle":"The Beginnings of Harmony Framework","url":"/harmony/blog/2025/01/11/how-it-started#the-goals-of-this-new-framework","content":" After finishing a Roblox project without any framework and seeing the resulting Experience not finding any audience, I've gained experience and thought for myself &quot;How can I not redo those mistakes ?&quot;. I thought of what a front-page game need and wrote these specifications:  Luau comfortable libraries that can be used in reactive context (Like Fusion or ReactLua)Admin commandsDetect exploits, cheats, authorize player actions like teleportingSafe, Typed &amp; Fast Client-Server communicationManage global stateManage, save, react and replicate player stateUse module architecture and have a better syntax that current Luau OOP syntax.Providers &amp; ComponentsUtility modulesEasy debugging and inspecting of behaviours while in-gameBe able to write some Scripts and LocalScripts that depends on Providers &amp; Compoents, even if most of the code is SSA.Not forced to use Rojo  Designing the framework  At first, I wasn't familiar with Wally and toolchains manager like aftman, foreman and rokit. (Just learned yesterday that Rokit must be used) ","version":null,"tagName":"h2"},{"title":"Your first Component","type":0,"sectionRef":"#","url":"/harmony/docs/NotDoneYet/Components","content":"","keywords":"","version":"Next"},{"title":"Create an empty Component​","type":1,"pageTitle":"Your first Component","url":"/harmony/docs/NotDoneYet/Components#create-an-empty-component","content":" -# wip  ","version":"Next","tagName":"h2"},{"title":"Set up methods and properties​","type":1,"pageTitle":"Your first Component","url":"/harmony/docs/NotDoneYet/Components#set-up-methods-and-properties","content":" -# wip  ","version":"Next","tagName":"h2"},{"title":"A Provider​","type":1,"pageTitle":"Your first Component","url":"/harmony/docs/NotDoneYet/Components#a-provider","content":" As expected, you can require Providers from anywhere.  ","version":"Next","tagName":"h2"},{"title":"Require another Component​","type":1,"pageTitle":"Your first Component","url":"/harmony/docs/NotDoneYet/Components#require-another-component","content":" -# wip ","version":"Next","tagName":"h2"},{"title":"Event","type":0,"sectionRef":"#","url":"/harmony/api/Event","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Event","url":"/harmony/api/Event#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Event","url":"/harmony/api/Event#new","content":"&lt;/&gt; Event.new( name: string, options: EventOptions? ) → Event Event  ","version":null,"tagName":"h3"},{"title":"Fire​","type":1,"pageTitle":"Event","url":"/harmony/api/Event#Fire","content":"&lt;/&gt; Event:Fire(...: any) → Event Fires the event  ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"Event","url":"/harmony/api/Event#Connect","content":"&lt;/&gt; Event:Connect( dependency: any, callback: () → () ) → Event Connects a depdency to this event. ","version":null,"tagName":"h3"},{"title":"Binding","type":0,"sectionRef":"#","url":"/harmony/api/Binding","content":"Binding","keywords":"","version":null},{"title":"Conventions","type":0,"sectionRef":"#","url":"/harmony/docs/More/NamingConventions","content":"","keywords":"","version":"Next"},{"title":"Provider​","type":1,"pageTitle":"Conventions","url":"/harmony/docs/More/NamingConventions#provider","content":" A provider method name should be PascalCase and their properties camelCase.  Only use Props and Methods values inside your service.self must never be used and methods must be pure functions, referencing Props or Methods if necessary.  Add a _ for private Props &amp; Methods. It seems unnecessary to put private fields in Props &amp; Methods, but it may be useful for debugging using Iris.  A base Harmony provider with a counter should look like this:  --!strict local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Harmony = require(ReplicatedStorage.Harmony) -- Properties local Props = { counter = 0, _privateProperty = 16 } -- Methods local Methods = {} function Methods.IncreaseCounter() Props.counter += 1 Methods.Print() end function Methods.Print() print(Props.counter) end -- Lifecycles function onInit() end function onInit() end -- Footer local self = Harmony.Provider.new(script.Name, Methods, Props) Harmony.Workers.OnInit:Connect(self, onInit) Harmony.Workers.OnStart:Connect(self, onInit) return self  ","version":"Next","tagName":"h2"},{"title":"ComponentFactory","type":0,"sectionRef":"#","url":"/harmony/api/ComponentFactory","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"ComponentFactory","url":"/harmony/api/ComponentFactory#functions","content":" ","version":null,"tagName":"h2"},{"title":"With​","type":1,"pageTitle":"ComponentFactory","url":"/harmony/api/ComponentFactory#With","content":"&lt;/&gt; ComponentFactory:With( methods: M &amp; {}, props: () → P &amp; {} ) → ComponentFactory Setup Props &amp; Components. local Methods = { DoSomething = function(self) print(self.counter) end } local function Props() return {counter=10} end -- ... :With(Methods, Props)   ","version":null,"tagName":"h3"},{"title":"New​","type":1,"pageTitle":"ComponentFactory","url":"/harmony/api/ComponentFactory#New","content":"&lt;/&gt; ComponentFactory:New(callback: (self:types.Component&lt;Instance &gt;) → ()) → ComponentFactory Runs the callback on the construction of a component after Props &amp; Methods, but before connections. For connecting signals, it's preferred to use ComponentFactory:Connect -- ... :New(function(self.me) self.me.Transparency = 1 end)   ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"ComponentFactory","url":"/harmony/api/ComponentFactory#Connect","content":"&lt;/&gt; ComponentFactory:Connect( event: string | RBXScriptSignal | types.Event&lt;T...&gt;, callback: ( self: types.Component&lt;Instance &gt;, T... ) → () ) → ComponentFactory Connects this Component to a Lifecycle or a Signal. Will always run AFTER Props &amp; Methods and New local function callback(self, ...) print(&quot;Event fired on&quot;, self.name, &quot;with arguments&quot;, ...) end -- ... :Connect(Harmony.Events.Heartbeat, callback) :Connect(workspace.ChildAdded, callback) :Connect(&quot;Touched&quot;, callback) -- Considering the Component attaches to a BasePart   ","version":null,"tagName":"h3"},{"title":"Bind​","type":1,"pageTitle":"ComponentFactory","url":"/harmony/api/ComponentFactory#Bind","content":"&lt;/&gt; ComponentFactory:Bind(tag: string) → Component Binds this Factory to a CollectionService tag. ","version":null,"tagName":"h3"},{"title":"Events","type":0,"sectionRef":"#","url":"/harmony/docs/Events","content":"Events Lifecycles Events are basically Signals that you can subscribe. Currently, only Providers can subscribe to Events. Like in Flamework, when Harmony:Init() is called, those events will be called in order: OnInit is called, each listener will be invoked and will yield. Very useful for initializing your module and making sure no big errors happens. OnStart is called after OnInit, a thread will be created for each listener. Good for your while loops","keywords":"","version":"Next"},{"title":"Component","type":0,"sectionRef":"#","url":"/harmony/api/Component","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/harmony/api/Component#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Component","url":"/harmony/api/Component#new","content":"&lt;/&gt; Component.new( _methods: M &amp; {}, props: P &amp; {} ) → () Used internally, use ComponentFactory  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Component","url":"/harmony/api/Component#Destroy","content":"&lt;/&gt; Component:Destroy() → () Calls the Janitor and prevents the properties from being changed.  ","version":null,"tagName":"h3"},{"title":"IsEnabled​","type":1,"pageTitle":"Component","url":"/harmony/api/Component#IsEnabled","content":"&lt;/&gt; Component:IsEnabled() → () Returns true if the Component is enabled.  ","version":null,"tagName":"h3"},{"title":"SetEnabled​","type":1,"pageTitle":"Component","url":"/harmony/api/Component#SetEnabled","content":"&lt;/&gt; Component:SetEnabled(enabled: boolean) → () Set the enabled state of the component.  ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"Component","url":"/harmony/api/Component#Connect","content":"&lt;/&gt; Component:Connect( signal: T &amp; (RBXScriptSignal | types.Event&lt;A...&gt;), callback: (A...) → () ) → () Connects the Component to a Signal or a Lifecycle, automatically adding to its janitor ","version":null,"tagName":"h3"},{"title":"Designing the framework","type":0,"sectionRef":"#","url":"/harmony/blog","content":"","keywords":"","version":null},{"title":"Introduction​","type":1,"pageTitle":"Designing the framework","url":"/harmony/blog#introduction","content":" ","version":null,"tagName":"h2"},{"title":"Where did it started and what did evolved ?​","type":1,"pageTitle":"Designing the framework","url":"/harmony/blog#where-did-it-started-and-what-did-evolved-","content":" Harmony Framework is a new Roblox framework I've been using internally for years. In its early stages, it was simply a set of libraries called Melody. However, as my projects grew, I realized my code had significant flaws, even with the libraries making things easier.  Global RemoteEvents weren’t typed and were poorly optimized. Global state management was also untyped, relying on ValueBase objects. RemoteEvents were untyped, inter-script communication used BindableEvents with major issues, and managing replicated player data was done with Attributes, which are very bandwidth-expensive. And on top of the cake, my code was not consistent at all.  Giving myself too much freedom on how to write code was the top of the cake. Inconsistencies everywheres, scripts parented in unusual places, questionnable naming conventions. I needed some sort of constraint to keep myself from rewriting the entire code every week.  At that point, I moved away from Melody Framework and started using RobloxTS, but it had its own set of issues. I needed quick development, and RobloxTS or Rojo tools didn’t fit the project’s conditions, so using Flamework wasn’t ideal. Knit was unmaintained (I think?), and it wasn't type-safe. Prvd m' Wrong is still in early development and didn’t meet my needs.  ","version":null,"tagName":"h2"},{"title":"The goals of this new framework​","type":1,"pageTitle":"Designing the framework","url":"/harmony/blog#the-goals-of-this-new-framework","content":" After finishing a Roblox project without any framework and seeing the resulting Experience not finding any audience, I've gained experience and thought for myself &quot;How can I not redo those mistakes ?&quot;. I thought of what a front-page game need and wrote these specifications:  Luau comfortable libraries that can be used in reactive context (Like Fusion or ReactLua)Admin commandsDetect exploits, cheats, authorize player actions like teleportingSafe, Typed &amp; Fast Client-Server communicationManage global stateManage, save, react and replicate player stateUse module architecture and have a better syntax that current Luau OOP syntax.Providers &amp; ComponentsUtility modulesEasy debugging and inspecting of behaviours while in-gameBe able to write some Scripts and LocalScripts that depends on Providers &amp; Compoents, even if most of the code is SSA.Not forced to use Rojo  Designing the framework  At first, I wasn't familiar with Wally and toolchains manager like aftman, foreman and rokit. (Just learned yesterday that Rokit must be used) ","version":null,"tagName":"h2"},{"title":"Provider","type":0,"sectionRef":"#","url":"/harmony/api/Provider","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Provider","url":"/harmony/api/Provider#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Provider","url":"/harmony/api/Provider#new","content":"&lt;/&gt; Provider.new( name: string, methods: M, props: P ) → Provider Creates a Provider named name using a sets of methods &amp; props, the resulting Provider object must not be used in itself.  ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"Provider","url":"/harmony/api/Provider#Connect","content":"&lt;/&gt; Provider:Connect( event: Event.Event&lt;T...&gt;, callback: (T...) → () ) → Provider Connects the Provider to a lifecycle Event.  ","version":null,"tagName":"h3"},{"title":"SetInterval​","type":1,"pageTitle":"Provider","url":"/harmony/api/Provider#SetInterval","content":"&lt;/&gt; Provider:SetInterval( interval: number, spawn: boolean, callback: () → () ) → Provider Starts a while loop, invoking the callback every interval seconds. Will subscribe to OnStart Lifecycle. Argument spawn describe whenever to call the callback through the engine scheduler ","version":null,"tagName":"h3"},{"title":"Harmony","type":0,"sectionRef":"#","url":"/harmony/api/Harmony","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Harmony","url":"/harmony/api/Harmony#functions","content":" ","version":null,"tagName":"h2"},{"title":"Add​","type":1,"pageTitle":"Harmony","url":"/harmony/api/Harmony#Add","content":"&lt;/&gt; Harmony:Add(instance: ModuleScript | Folder ) → Harmony Add a ModuleScript or a Folder containing ModuleScripts to Load  ","version":null,"tagName":"h3"},{"title":"Init​","type":1,"pageTitle":"Harmony","url":"/harmony/api/Harmony#Init","content":"&lt;/&gt; Harmony:Init() → Harmony Loads all modules, starts lifecycles and mark Harmony as inited  ","version":null,"tagName":"h3"},{"title":"AllowTelemetry​","type":1,"pageTitle":"Harmony","url":"/harmony/api/Harmony#AllowTelemetry","content":"&lt;/&gt; Harmony:AllowTelemetry(callback: (player:Player) → boolean) → Harmony Allows defined players to use Telemetry, the callback is invoked each time a player joins  ","version":null,"tagName":"h3"},{"title":"Expect​","type":1,"pageTitle":"Harmony","url":"/harmony/api/Harmony#Expect","content":"&lt;/&gt; Harmony:Expect(t: T) → T Currently unused, later used for dependency management ?  ","version":null,"tagName":"h3"},{"title":"Wait​","type":1,"pageTitle":"Harmony","url":"/harmony/api/Harmony#Wait","content":"&lt;/&gt; Harmony:Wait() → Harmony Yields until Harmony is inited. Required when using the Framework in a LocalScript or a Script. local Harmony = require(ReplicatedStorage.Harmony):Wait()  ","version":null,"tagName":"h3"},{"title":"Providers","type":0,"sectionRef":"#","url":"/harmony/docs/Providers","content":"","keywords":"","version":"Next"},{"title":"Create an empty provider​","type":1,"pageTitle":"Providers","url":"/harmony/docs/Providers#create-an-empty-provider","content":" ","version":"Next","tagName":"h2"},{"title":"Using the Plugin​","type":1,"pageTitle":"Providers","url":"/harmony/docs/Providers#using-the-plugin","content":" In the toolbar, there is a button named &quot;Create Provider&quot; and a pop-up window will appear to choose a name. Adding slashes in the name will place it in a subfolder (or create if it does not exists). For example; creating a service in the server and choosing the name economy/MoneyService will place it in ServerScriptService/Services/economy/MoneyService.luau if created default bootstrap scripts.  You can choose to place it in:  Server: Only if there is a folder tagged with both Provider &amp; ServerClient: Only if there is a folder tagged with both Provider &amp; Client  ","version":"Next","tagName":"h3"},{"title":"Set up methods and properties​","type":1,"pageTitle":"Providers","url":"/harmony/docs/Providers#set-up-methods-and-properties","content":" A Provider contains its own Props &amp; Methods that will be fused when returned. Note that self must not be used and that Props &amp; Methods should be used instead.  For example, we have the Props &amp; Methods for a central bank.  local Props = { money = 0, debt = 0 } local Methods = {} function Methods.Deposit(amount:number) Props.money += amount end function Methods.Withdraw(amount:number) if amount &gt; Props.money then Methods.Loan(amount - Props.money) end Props.money -= amount end function Methods.Loan(amount: number) Props.debt += amount Props.money += amount end   ","version":"Next","tagName":"h2"},{"title":"Require another provider​","type":1,"pageTitle":"Providers","url":"/harmony/docs/Providers#require-another-provider","content":" When you require one Provider, you will see it as a table containing methods and props and you can directly work with it.  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local ServerScriptService = game:GetService(&quot;ServerScriptService&quot;) local Harmony = require(ReplicatedStorage.Harmony):Wait() local BankService = require(ServerScriptService.Services.BankService) BankService.Deposit(100) BankService.Withdraw(120) print(BankService.debt) --&gt; 20 print(BankService) --&gt; BankService{money=0,debt=20} print(getmetatable(BankService::any))  ","version":"Next","tagName":"h2"},{"title":"Globals & Player State","type":0,"sectionRef":"#","url":"/harmony/docs/NotDoneYet/WorkingWithGlobals","content":"Globals &amp; Player State Harmony solves the problem of managing and replicating data for you. For this, you have to declare your ByteNet remotes, your Player State and your Global State in ReplicatedStorage/Defs.luau --!strict local Harmony = require(game:GetService(&quot;ReplicatedStorage&quot;).Harmony) local Net = Harmony.State.DefineNetworking(function(b, packet) return { -- Define your packets here, refer to documentation of ByteNet } end) local GlobalState = Harmony.State.DefineGlobal(function(use) return { Timer = use(60) } end) local PlayerState = Harmony.State.DefinePlayer(function(use, Flag) return { Coins = use(10, {Flag.Save, Flag.Replicate}), -- Will save to ProfileStore &amp; Replicate to player SessionTime = use(10, {Flag.Replicate}), -- Will just replicate to player without saving } end) -- Not necessary export type Net = typeof(Net) export type GlobalState = typeof(GlobalState) export type PlayerState = typeof(PlayerState) return Harmony.State.Setup(GlobalState, PlayerState, Net) ","keywords":"","version":"Next"}],"options":{"id":"default"}}